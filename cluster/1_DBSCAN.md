db = DBSCAN(eps=0.3, min_samples=10).fit(X)
- **db.components_:** 过滤后的样本
- **db.labels_:** 样本的标签

dbscan: 基于密度的, 发现任意形状, 对大型具有形状的数据高效,
根据形状聚类?

对大量具有形状的数据进行聚类, 有如下要求:
1. 最少的先验知识, 即最少的输入参数
2. 发现任意形状的聚类
3. 高效的处理大的数据样本

kmeans和kmedoid方法的区别: 一个是重新计算重心, 一个是之直接使用离中心最近的点

wrt.(with respect to, 关于)

- 对于一个点的情况: 
- 为什么有绝对值? |Neps(p)|

- 理想情况下的输入参数: eps(样本之间的距离阈值) minPts(集合的样本点阈值) centers(各集合中的一个点) 

- 使用全局的 eps和 minPts 会导致两个里的近的密度不同的集合被合并为一个集合

## 设置EPS-启发式算法
设置的为全局 EPS和MinPnt, 即对每个集合都使用一样的参数
- 先确定 MinPnt, 根据经验 MinPnt >= 样本的维度, 对于2维样本, 设置MinPnt为6
- 选择一个点计算其到其它他点之间的距离,得到距离集合
- 对距离集合按升序排序, 记录排在第6的距离值
- 对集合中的每个点都完成2,3步操作后, 得到一个集合B, 集合中的每个值为排在第6的距离值
- 对集合B进行降序排序, 并作图, 从图中选择处于谷底的值作为 eps

## 编程
- 使用 np.where 得到每个集合
- 对集合取均值, 作为一个簇

